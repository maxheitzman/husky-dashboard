<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS Sensor Data Poisoning Detection Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        .header {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 20px 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .header h1 { color: #00d4ff; font-size: 28px; margin-bottom: 5px; }
        .header p { color: #a0a0a0; font-size: 14px; }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            transition: all 0.3s;
        }
        
        .tab:hover { background: rgba(255,255,255,0.2); transform: translateY(-2px); }
        .tab.active { background: #00d4ff; color: #000; border-color: #00d4ff; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .card h2 { color: #00d4ff; font-size: 18px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        
        .metrics-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-box {
            background: rgba(0,212,255,0.1);
            border: 1px solid rgba(0,212,255,0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .metric-label { font-size: 11px; color: #a0a0a0; text-transform: uppercase; margin-bottom: 5px; }
        .metric-value { font-size: 28px; font-weight: bold; color: #00d4ff; }
        .metric-value.danger { color: #ff4757; }
        .metric-value.success { color: #2ed573; }
        .metric-value.warning { color: #ffa502; }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { background: #00d4ff; color: #000; }
        .btn-primary:hover:not(:disabled) { background: #00b8e6; transform: translateY(-1px); }
        .btn-danger { background: #ff4757; color: #fff; }
        .btn-success { background: #2ed573; color: #000; }
        .btn-warning { background: #ffa502; color: #000; }
        
        .button-row { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        
        .grid-2 { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        @media (max-width: 1000px) { .grid-2 { grid-template-columns: 1fr; } }
        
        #trajectoryCanvas, #liveGridCanvas {
            width: 100%;
            height: 400px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #liveGridCanvas {
            background: linear-gradient(135deg, rgba(0,0,0,0.5) 0%, rgba(20,20,40,0.5) 100%);
        }
        
        .legend { display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        
        .trust-bar-container { margin-bottom: 15px; }
        .trust-label { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 13px; }
        .trust-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .trust-fill { height: 100%; transition: width 0.3s, background 0.3s; }
        .trust-high { background: #2ed573; }
        .trust-medium { background: #ffa502; }
        .trust-low { background: #ff4757; }
        
        .anomaly-list { max-height: 300px; overflow-y: auto; }
        .anomaly-item {
            background: rgba(255,71,87,0.1);
            border-left: 3px solid #ff4757;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .anomaly-time { font-weight: bold; color: #ff4757; }
        .anomaly-reasons { font-size: 12px; color: #a0a0a0; margin-top: 5px; }
        
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .preset-card {
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .preset-card:hover { border-color: #00d4ff; background: rgba(0,212,255,0.1); }
        .preset-card.selected { border-color: #00d4ff; background: #00d4ff; color: #000; }
        .preset-name { font-weight: bold; font-size: 13px; }
        .preset-desc { font-size: 11px; opacity: 0.7; margin-top: 3px; }
        
        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .form-group label { display: block; font-size: 11px; color: #a0a0a0; margin-bottom: 5px; }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 14px;
        }
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        .status-idle { background: rgba(255,255,255,0.1); }
        .status-processing { background: #2ed573; color: #000; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        .file-upload {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .file-upload:hover { border-color: #00d4ff; background: rgba(0,212,255,0.05); }
        .file-upload input { display: none; }
        
        .validation-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .status-box { padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .status-box.info { background: rgba(0,212,255,0.1); border: 1px solid #00d4ff; }
        .status-box.success { background: rgba(46,213,115,0.1); border: 1px solid #2ed573; }
        .status-box.warning { background: rgba(255,165,2,0.1); border: 1px solid #ffa502; }
        .status-box.error { background: rgba(255,71,87,0.1); border: 1px solid #ff4757; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ROS Sensor Data Poisoning Detection</h1>
            <p>Inject poison attacks, monitor real-time detection, and validate system accuracy</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('dashboard')">üìä Live Dashboard</button>
            <button class="tab" onclick="switchTab('help')">‚ùì Help</button>
        </div>
        
        <!-- Tab 1: Live Dashboard -->
        <div id="dashboard" class="tab-content active">
            <!-- Controls -->
            <div class="card">
                <h2>‚öôÔ∏è Processing Controls</h2>
                <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center;">
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".bag,.zip" onchange="handleFileSelect(event)">
                        <div>üìÅ <span id="fileName">Click to select bag file (.bag or .zip)</span></div>
                    </div>
                    <div class="button-row" style="margin-top: 0;">
                        <button class="btn-primary" id="startBtn" onclick="startProcessing(false)">‚ñ∂Ô∏è Start</button>
                        <button class="btn-danger" id="stopBtn" onclick="stopProcessing()" disabled>‚èπÔ∏è Stop</button>
                        <button class="btn-warning" id="downloadAllBtn" onclick="downloadAllData()" disabled>üì• Download All Data</button>
                        <button class="btn-warning" id="downloadAnomaliesBtn" onclick="downloadAnomalies()" disabled>üì• Download Anomalies</button>
                    </div>
                    <span class="status-badge status-idle" id="statusBadge">‚óè Idle</span>
                </div>
                <div style="margin-top: 15px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label style="color: #a0a0a0; font-size: 14px;">Anomaly Detection Boundary (degrees):</label>
                    <input type="number" id="thresholdInput" value="2.0" min="0.1" max="100" step="0.1" 
                           style="padding: 8px 12px; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; 
                                  background: rgba(255,255,255,0.05); color: #fff; width: 80px; font-size: 14px;">
                    <button class="btn-warning" onclick="changeThreshold()" id="changeThresholdBtn">Change</button>
                    <span style="color: #a0a0a0; font-size: 12px;" id="currentThreshold">Current: 2.0¬∞</span>
                </div>
            </div>
            
            <!-- Metrics -->
            <div class="metrics-row">
                <div class="metric-box">
                    <div class="metric-label">Total Readings</div>
                    <div class="metric-value" id="totalReadings">0</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Anomalies</div>
                    <div class="metric-value danger" id="anomaliesCount">0</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Detection Rate</div>
                    <div class="metric-value warning" id="detectionRate">0%</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Avg Time</div>
                    <div class="metric-value success" id="avgTime">0ms</div>
                </div>
                <div class="metric-box">
                    <div class="metric-label">Timestamp</div>
                    <div class="metric-value" id="currentTime">0.0s</div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="grid-2">
                <!-- Live Grid Map -->
                <div class="card">
                    <h2>üìç Live Position Grid</h2>
                    <div style="position: relative;">
                        <canvas id="liveGridCanvas"></canvas>
                        <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 5px; font-size: 12px;">
                            <div>Lat: <span id="currentLat">--</span>¬∞</div>
                            <div>Lon: <span id="currentLon">--</span>¬∞</div>
                            <div id="predictionInfo" style="margin-top: 5px; font-size: 10px; color: #ffa502; display: none;">
                                Pred: <span id="predictedLat">--</span>¬∞, <span id="predictedLon">--</span>¬∞
                            </div>
                        </div>
                    </div>
                    <div class="legend" style="margin-top: 10px;">
                        <div class="legend-item"><div class="legend-dot" style="background:#00d4ff"></div> Current</div>
                        <div class="legend-item"><div class="legend-dot" style="background:#ffa502"></div> Predicted</div>
                    </div>
                </div>
                
                <!-- GPS Trajectory -->
                <div class="card">
                    <h2>üó∫Ô∏è GPS Trajectory</h2>
                    <canvas id="trajectoryCanvas"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot" style="background:#2ed573"></div> Start</div>
                        <div class="legend-item"><div class="legend-dot" style="background:#00d4ff"></div> Normal</div>
                        <div class="legend-item"><div class="legend-dot" style="background:#ff4757"></div> Poisoned</div>
                        <div class="legend-item"><div class="legend-dot" style="background:#a55eea"></div> Current</div>
                        <div class="legend-item">üö© Anomaly</div>
                    </div>
                </div>
                
                <!-- Side Panel -->
                <div>
                    <!-- Trust Score -->
                    <div class="card">
                        <h2>üéØ Trust Score</h2>
                        <div class="trust-bar-container">
                            <div class="trust-label"><span>GPS Prediction Accuracy</span><span id="trustScore">100%</span></div>
                            <div class="trust-bar"><div class="trust-fill trust-high" id="trustBar" style="width:100%"></div></div>
                        </div>
                    </div>
                    
                    <!-- Anomalies -->
                    <div class="card">
                        <h2>üö® Recent Anomalies</h2>
                        <div class="anomaly-list" id="anomalyList">
                            <div style="text-align:center;color:#666;padding:20px;">No anomalies detected</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 4: Help -->
        <div id="help" class="tab-content">
            <div class="card">
                <h2>üìñ Quick Guide</h2>
                <div style="line-height:1.8">
                    <p><strong>1. Live Dashboard:</strong> Upload bag file or use synthetic data, watch real-time processing</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:5000/api';
        let processorId = null;
        let statusInterval = null;
        window.anomalyPopupShown = false;  // Track if anomaly popup has been shown
        let selectedFile = null;
        let selectedPreset = null;
        let canvas, ctx;
        let liveGridCanvas, liveGridCtx;
        let currentPosition = null;
        let positionHistory = [];
        let gridBounds = { minLat: null, maxLat: null, minLon: null, maxLon: null };
        
        window.onload = async function() {
            // Trajectory canvas
            canvas = document.getElementById('trajectoryCanvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            ctx = canvas.getContext('2d');
            drawEmptyCanvas();
            
            // Live grid canvas
            liveGridCanvas = document.getElementById('liveGridCanvas');
            liveGridCanvas.width = liveGridCanvas.offsetWidth;
            liveGridCanvas.height = liveGridCanvas.offsetHeight;
            liveGridCtx = liveGridCanvas.getContext('2d');
            drawEmptyGrid();
            
            
            try {
                const r = await fetch(`${API_BASE}/health`);
                const d = await r.json();
                console.log('‚úì API:', d.message);
            } catch (e) {
                alert('API not connected. Start server with: python3 app.py');
            }
        };
        
        function switchTab(name) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(name).classList.add('active');
        }
        
        function drawEmptyCanvas() {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#666';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Waiting for data...', canvas.width/2, canvas.height/2);
        }
        
        function drawEmptyGrid() {
            if (!liveGridCtx) return;
            // Clear canvas
            liveGridCtx.fillStyle = 'rgba(0,0,0,0.5)';
            liveGridCtx.fillRect(0, 0, liveGridCanvas.width, liveGridCanvas.height);
            
            // Draw grid
            drawGrid();
            
            // Draw compass labels
            drawCompassLabels();
            
            // Draw center message
            liveGridCtx.fillStyle = '#666';
            liveGridCtx.font = '16px Arial';
            liveGridCtx.textAlign = 'center';
            liveGridCtx.fillText('Waiting for GPS data...', liveGridCanvas.width/2, liveGridCanvas.height/2);
        }
        
        function drawGrid() {
            if (!liveGridCtx) return;
            const gridSize = 20;
            const padding = 50;
            const width = liveGridCanvas.width - 2 * padding;
            const height = liveGridCanvas.height - 2 * padding;
            
            liveGridCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            liveGridCtx.lineWidth = 1;
            
            // Vertical lines
            for (let i = 0; i <= gridSize; i++) {
                const x = padding + (i * width / gridSize);
                liveGridCtx.beginPath();
                liveGridCtx.moveTo(x, padding);
                liveGridCtx.lineTo(x, padding + height);
                liveGridCtx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= gridSize; i++) {
                const y = padding + (i * height / gridSize);
                liveGridCtx.beginPath();
                liveGridCtx.moveTo(padding, y);
                liveGridCtx.lineTo(padding + width, y);
                liveGridCtx.stroke();
            }
            
            // Center crosshair
            const centerX = padding + width / 2;
            const centerY = padding + height / 2;
            liveGridCtx.strokeStyle = 'rgba(0,212,255,0.5)';
            liveGridCtx.lineWidth = 2;
            liveGridCtx.setLineDash([5, 5]);
            liveGridCtx.beginPath();
            liveGridCtx.moveTo(centerX, padding);
            liveGridCtx.lineTo(centerX, padding + height);
            liveGridCtx.moveTo(padding, centerY);
            liveGridCtx.lineTo(padding + width, centerY);
            liveGridCtx.stroke();
            liveGridCtx.setLineDash([]);
        }
        
        function drawCompassLabels() {
            if (!liveGridCtx) return;
            const padding = 50;
            liveGridCtx.fillStyle = '#00d4ff';
            liveGridCtx.font = 'bold 18px Arial';
            liveGridCtx.textAlign = 'center';
            liveGridCtx.textBaseline = 'middle';
            
            // North (top)
            liveGridCtx.fillText('N', liveGridCanvas.width / 2, 20);
            
            // South (bottom)
            liveGridCtx.fillText('S', liveGridCanvas.width / 2, liveGridCanvas.height - 20);
            
            // East (right)
            liveGridCtx.textAlign = 'left';
            liveGridCtx.fillText('E', liveGridCanvas.width - 30, liveGridCanvas.height / 2);
            
            // West (left)
            liveGridCtx.textAlign = 'right';
            liveGridCtx.fillText('W', 30, liveGridCanvas.height / 2);
        }
        
        let latestPrediction = null;
        
        function updateLiveGrid(lat, lon, predictions = null) {
            if (!liveGridCtx || lat === null || lon === null || isNaN(lat) || isNaN(lon)) return;
            
            // Update current position
            currentPosition = { lat, lon };
            positionHistory.push({ lat, lon, time: Date.now() });
            
            // Keep only last 100 points for trail
            if (positionHistory.length > 100) {
                positionHistory.shift();
            }
            
            // Store latest prediction
            if (predictions && predictions.length > 0) {
                latestPrediction = predictions[predictions.length - 1];
            }
            
            // Update bounds (include predictions in bounds)
            if (gridBounds.minLat === null) {
                gridBounds = { minLat: lat, maxLat: lat, minLon: lon, maxLon: lon };
            } else {
                gridBounds.minLat = Math.min(gridBounds.minLat, lat);
                gridBounds.maxLat = Math.max(gridBounds.maxLat, lat);
                gridBounds.minLon = Math.min(gridBounds.minLon, lon);
                gridBounds.maxLon = Math.max(gridBounds.maxLon, lon);
            }
            
            // Include prediction in bounds if available
            if (latestPrediction) {
                gridBounds.minLat = Math.min(gridBounds.minLat, latestPrediction.predicted_lat);
                gridBounds.maxLat = Math.max(gridBounds.maxLat, latestPrediction.predicted_lat);
                gridBounds.minLon = Math.min(gridBounds.minLon, latestPrediction.predicted_lon);
                gridBounds.maxLon = Math.max(gridBounds.maxLon, latestPrediction.predicted_lon);
            }
            
            // Update display
            const latEl = document.getElementById('currentLat');
            const lonEl = document.getElementById('currentLon');
            if (latEl) latEl.textContent = lat.toFixed(6);
            if (lonEl) lonEl.textContent = lon.toFixed(6);
            
            // Redraw grid
            drawLiveGrid();
        }
        
        function drawLiveGrid() {
            if (!liveGridCtx) return;
            // Clear canvas
            liveGridCtx.fillStyle = 'rgba(0,0,0,0.5)';
            liveGridCtx.fillRect(0, 0, liveGridCanvas.width, liveGridCanvas.height);
            
            // Draw grid
            drawGrid();
            
            // Draw compass labels
            drawCompassLabels();
            
            if (!currentPosition) return;
            
            const padding = 50;
            const width = liveGridCanvas.width - 2 * padding;
            const height = liveGridCanvas.height - 2 * padding;
            
            // Calculate scale and offset
            const latRange = gridBounds.maxLat - gridBounds.minLat || 0.001;
            const lonRange = gridBounds.maxLon - gridBounds.minLon || 0.001;
            
            // Add padding to bounds
            const latPadding = latRange * 0.1;
            const lonPadding = lonRange * 0.1;
            
            const scaleX = width / (lonRange + 2 * lonPadding);
            const scaleY = height / (latRange + 2 * latPadding);
            
            const toX = (lon) => padding + (lon - gridBounds.minLon + lonPadding) * scaleX;
            const toY = (lat) => padding + height - (lat - gridBounds.minLat + latPadding) * scaleY;
            
            // Draw position trail
            if (positionHistory.length > 1) {
                liveGridCtx.strokeStyle = 'rgba(0,212,255,0.3)';
                liveGridCtx.lineWidth = 2;
                liveGridCtx.beginPath();
                for (let i = 0; i < positionHistory.length; i++) {
                    const pos = positionHistory[i];
                    const x = toX(pos.lon);
                    const y = toY(pos.lat);
                    if (i === 0) {
                        liveGridCtx.moveTo(x, y);
                    } else {
                        liveGridCtx.lineTo(x, y);
                    }
                }
                liveGridCtx.stroke();
            }
            
            // Draw current position point
            const x = toX(currentPosition.lon);
            const y = toY(currentPosition.lat);
            
            // Draw point with glow effect
            const gradient = liveGridCtx.createRadialGradient(x, y, 0, x, y, 15);
            gradient.addColorStop(0, 'rgba(0,212,255,1)');
            gradient.addColorStop(0.5, 'rgba(0,212,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,212,255,0)');
            liveGridCtx.fillStyle = gradient;
            liveGridCtx.beginPath();
            liveGridCtx.arc(x, y, 15, 0, Math.PI * 2);
            liveGridCtx.fill();
            
            // Draw point center
            liveGridCtx.fillStyle = '#00d4ff';
            liveGridCtx.beginPath();
            liveGridCtx.arc(x, y, 6, 0, Math.PI * 2);
            liveGridCtx.fill();
            
            // Draw white border
            liveGridCtx.strokeStyle = '#fff';
            liveGridCtx.lineWidth = 2;
            liveGridCtx.beginPath();
            liveGridCtx.arc(x, y, 6, 0, Math.PI * 2);
            liveGridCtx.stroke();
            
            // Draw predicted next position if available
            if (latestPrediction && latestPrediction.predicted_lat && latestPrediction.predicted_lon) {
                const predX = toX(latestPrediction.predicted_lon);
                const predY = toY(latestPrediction.predicted_lat);
                
                // Check if prediction is within canvas bounds
                if (predX >= 0 && predX <= liveGridCanvas.width && predY >= 0 && predY <= liveGridCanvas.height) {
                    // Update prediction info display
                    const predInfo = document.getElementById('predictionInfo');
                    const predLatEl = document.getElementById('predictedLat');
                    const predLonEl = document.getElementById('predictedLon');
                    if (predInfo) predInfo.style.display = 'block';
                    if (predLatEl) predLatEl.textContent = latestPrediction.predicted_lat.toFixed(6);
                    if (predLonEl) predLonEl.textContent = latestPrediction.predicted_lon.toFixed(6);
                    
                    // Debug: Log prediction coordinates
                    console.log('Drawing prediction:', {
                        lat: latestPrediction.predicted_lat,
                        lon: latestPrediction.predicted_lon,
                        x: predX,
                        y: predY,
                        canvasSize: {w: liveGridCanvas.width, h: liveGridCanvas.height}
                    });
                } else {
                    console.log('Prediction outside canvas bounds:', {predX, predY, canvasW: liveGridCanvas.width, canvasH: liveGridCanvas.height});
                }
                
                // Draw line from current to predicted
                liveGridCtx.strokeStyle = 'rgba(255,165,2,0.6)';
                liveGridCtx.lineWidth = 2;
                liveGridCtx.setLineDash([5, 5]);
                liveGridCtx.beginPath();
                liveGridCtx.moveTo(x, y);
                liveGridCtx.lineTo(predX, predY);
                liveGridCtx.stroke();
                liveGridCtx.setLineDash([]);
                
                // Draw predicted point with orange/yellow color
                const predGradient = liveGridCtx.createRadialGradient(predX, predY, 0, predX, predY, 12);
                predGradient.addColorStop(0, 'rgba(255,165,2,0.8)');
                predGradient.addColorStop(0.5, 'rgba(255,165,2,0.4)');
                predGradient.addColorStop(1, 'rgba(255,165,2,0)');
                liveGridCtx.fillStyle = predGradient;
                liveGridCtx.beginPath();
                liveGridCtx.arc(predX, predY, 12, 0, Math.PI * 2);
                liveGridCtx.fill();
                
                // Draw predicted point center
                liveGridCtx.fillStyle = '#ffa502';
                liveGridCtx.beginPath();
                liveGridCtx.arc(predX, predY, 5, 0, Math.PI * 2);
                liveGridCtx.fill();
                
                // Draw white border for prediction
                liveGridCtx.strokeStyle = '#fff';
                liveGridCtx.lineWidth = 1.5;
                liveGridCtx.beginPath();
                liveGridCtx.arc(predX, predY, 5, 0, Math.PI * 2);
                liveGridCtx.stroke();
                
                // Draw label
                liveGridCtx.fillStyle = '#ffa502';
                liveGridCtx.font = 'bold 12px Arial';
                liveGridCtx.textAlign = 'center';
                liveGridCtx.fillText('Pred', predX, predY - 18);
            } else {
                // Hide prediction info if no prediction
                const predInfo = document.getElementById('predictionInfo');
                if (predInfo) predInfo.style.display = 'none';
            }
        }
        
        function handleFileSelect(e) {
            selectedFile = e.target.files[0];
            document.getElementById('fileName').textContent = selectedFile ? selectedFile.name : 'Click to select bag file';
        }
        
        function showAnomalyPopup(anomalyData, processorId) {
            console.log('[POPUP] showAnomalyPopup called with:', { anomalyData, processorId });
            
            // Remove any existing popup first
            const existingPopup = document.getElementById('anomalyPopupOverlay');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.id = 'anomalyPopupOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            // Create popup content
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: #1a1a2e;
                border: 2px solid #ff4444;
                border-radius: 15px;
                padding: 30px;
                max-width: 90%;
                max-height: 90%;
                overflow: auto;
                box-shadow: 0 10px 40px rgba(255, 68, 68, 0.3);
            `;
            
            // Create canvas for trajectory visualization
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 600;
            canvas.style.cssText = 'border: 1px solid #333; border-radius: 8px; margin: 20px 0;';
            
            // Popup content
            popup.innerHTML = `
                <h2 style="color: #ff4444; margin-bottom: 20px;">üö® Critical GPS Anomaly Detected</h2>
                <div style="margin-bottom: 20px;">
                    <p><strong>Anomaly Time:</strong> ${anomalyData.anomaly_timestamp.toFixed(2)}s</p>
                    <p><strong>Latitude Difference:</strong> ${anomalyData.lat_diff_degrees.toFixed(6)}¬∞</p>
                    <p><strong>Longitude Difference:</strong> ${anomalyData.lon_diff_degrees.toFixed(6)}¬∞</p>
                    <p><strong>Anomaly Location:</strong> (${anomalyData.anomaly_lat.toFixed(6)}, ${anomalyData.anomaly_lon.toFixed(6)})</p>
                    <p><strong>Predicted Location:</strong> (${anomalyData.predicted_lat.toFixed(6)}, ${anomalyData.predicted_lon.toFixed(6)})</p>
                </div>
                <h3 style="color: #00d4ff; margin: 20px 0 10px 0;">Last 5 Seconds of Motion</h3>
            `;
            
            popup.appendChild(canvas);
            
            // Action buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 15px; margin-top: 20px; justify-content: center;';
            
            const stopButton = document.createElement('button');
            stopButton.textContent = 'üõë Stop Rover';
            stopButton.style.cssText = `
                padding: 12px 30px;
                background: #ff4444;
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
            `;
            stopButton.onclick = async () => {
                // Close popup immediately
                overlay.remove();
                window.anomalyPopupShown = false;
                // Mark this anomaly as dismissed so it doesn't show again
                if (anomalyData && anomalyData.anomaly_timestamp) {
                    if (!window.dismissedAnomalies) {
                        window.dismissedAnomalies = new Set();
                    }
                    window.dismissedAnomalies.add(anomalyData.anomaly_timestamp);
                }
                
                // Clear anomaly data on backend to prevent popup from showing again
                try {
                    await fetch(`${API_BASE}/process/${processorId}/dismiss-anomaly`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                } catch (e) {
                    console.error('Error dismissing anomaly:', e);
                }
                
                alert('Rover stop command sent');
            };
            
            const resumeButton = document.createElement('button');
            resumeButton.textContent = '‚ñ∂Ô∏è Resume Script';
            resumeButton.style.cssText = `
                padding: 12px 30px;
                background: #00d4ff;
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
            `;
            resumeButton.onclick = async () => {
                // Close popup immediately
                overlay.remove();
                window.anomalyPopupShown = false;
                // Mark this anomaly as dismissed so it doesn't show again
                if (anomalyData && anomalyData.anomaly_timestamp) {
                    if (!window.dismissedAnomalies) {
                        window.dismissedAnomalies = new Set();
                    }
                    window.dismissedAnomalies.add(anomalyData.anomaly_timestamp);
                }
                
                // Clear anomaly data on backend to prevent popup from showing again
                try {
                    await fetch(`${API_BASE}/process/${processorId}/dismiss-anomaly`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                } catch (e) {
                    console.error('Error dismissing anomaly:', e);
                }
                
                try {
                    const res = await fetch(`${API_BASE}/process/${processorId}/resume`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const result = await res.json();
                    if (res.ok) {
                        console.log('Script resumed successfully from index:', result.resume_index);
                        // Update status badge
                        document.getElementById('statusBadge').className = 'status-badge status-processing';
                        document.getElementById('statusBadge').textContent = '‚óè Processing';
                    } else {
                        alert('Error resuming: ' + (result.error || 'Unknown error'));
                    }
                } catch (e) {
                    alert('Error resuming script: ' + e.message);
                }
            };
            
            buttonContainer.appendChild(stopButton);
            buttonContainer.appendChild(resumeButton);
            popup.appendChild(buttonContainer);
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Draw trajectory on canvas
            drawAnomalyTrajectory(canvas, anomalyData);
        }
        
        function drawAnomalyTrajectory(canvas, anomalyData) {
            const ctx = canvas.getContext('2d');
            const motionHistory = anomalyData.motion_history || [];
            
            if (motionHistory.length === 0) {
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No motion data available', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate bounds
            const lats = motionHistory.map(m => m.gps_lat).filter(l => l !== null);
            const lons = motionHistory.map(m => m.gps_lon).filter(l => l !== null);
            
            if (lats.length === 0 || lons.length === 0) return;
            
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);
            
            // Add anomaly coordinates to bounds
            const allLats = [...lats, anomalyData.anomaly_lat, anomalyData.predicted_lat];
            const allLons = [...lons, anomalyData.anomaly_lon, anomalyData.predicted_lon];
            const finalMinLat = Math.min(...allLats);
            const finalMaxLat = Math.max(...allLats);
            const finalMinLon = Math.min(...allLons);
            const finalMaxLon = Math.max(...allLons);
            
            // Add padding
            const latRange = finalMaxLat - finalMinLat || 0.001;
            const lonRange = finalMaxLon - finalMinLon || 0.001;
            const padding = 0.1;
            
            const scaleX = (canvas.width - 100) / (lonRange * (1 + 2 * padding));
            const scaleY = (canvas.height - 100) / (latRange * (1 + 2 * padding));
            
            const toX = (lon) => 50 + (lon - finalMinLon + lonRange * padding) * scaleX;
            const toY = (lat) => 50 + (canvas.height - 100) - (lat - finalMinLat + latRange * padding) * scaleY;
            
            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 50 + (canvas.width - 100) * i / 10;
                const y = 50 + (canvas.height - 100) * i / 10;
                ctx.beginPath();
                ctx.moveTo(x, 50);
                ctx.lineTo(x, canvas.height - 50);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(canvas.width - 50, y);
                ctx.stroke();
            }
            
            // Draw trajectory (normal points in blue)
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < motionHistory.length; i++) {
                const m = motionHistory[i];
                if (m.gps_lat !== null && m.gps_lon !== null) {
                    const x = toX(m.gps_lon);
                    const y = toY(m.gps_lat);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            ctx.stroke();
            
            // Draw normal GPS points
            ctx.fillStyle = '#00d4ff';
            for (const m of motionHistory) {
                if (m.gps_lat !== null && m.gps_lon !== null) {
                    const x = toX(m.gps_lon);
                    const y = toY(m.gps_lat);
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw predicted point (orange)
            ctx.fillStyle = '#ffa502';
            const predX = toX(anomalyData.predicted_lon);
            const predY = toY(anomalyData.predicted_lat);
            ctx.beginPath();
            ctx.arc(predX, predY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Predicted', predX, predY - 10);
            
            // Draw anomaly point (RED)
            ctx.fillStyle = '#ff4444';
            const anomX = toX(anomalyData.anomaly_lon);
            const anomY = toY(anomalyData.anomaly_lat);
            ctx.beginPath();
            ctx.arc(anomX, anomY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('ANOMALY', anomX, anomY - 12);
            
            // Draw line from predicted to actual
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(predX, predY);
            ctx.lineTo(anomX, anomY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Normal GPS', 20, 30);
            ctx.fillStyle = '#ffa502';
            ctx.fillText('Predicted', 20, 50);
            ctx.fillStyle = '#ff4444';
            ctx.fillText('Anomaly (RED)', 20, 70);
        }
        
        async function startProcessing(useSynthetic) {
            try {
                // Reset popup flags when starting new processing
                window.anomalyPopupShown = false;
                window.dismissedAnomalies = new Set();
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('downloadAllBtn').disabled = false;
                document.getElementById('downloadAnomaliesBtn').disabled = false;
                // Disable threshold controls during processing
                document.getElementById('thresholdInput').disabled = true;
                document.getElementById('changeThresholdBtn').disabled = true;
                document.getElementById('statusBadge').className = 'status-badge status-processing';
                document.getElementById('statusBadge').textContent = '‚óè Processing';
                
                // Get threshold from input or use global threshold
                const thresholdValue = parseFloat(document.getElementById('thresholdInput').value) || globalThreshold || 2.0;
                const body = { 
                    useSynthetic, 
                    config: { 
                        predictionWindow: 5, 
                        velocityThreshold: 5.0,
                        anomaly_threshold_degrees: thresholdValue
                    } 
                };
                
                if (!useSynthetic && selectedFile) {
                    const formData = new FormData();
                    formData.append('file', selectedFile);
                    const uploadRes = await fetch(`${API_BASE}/upload`, { method: 'POST', body: formData });
                    if (!uploadRes.ok) throw new Error('Upload failed');
                    const uploadData = await uploadRes.json();
                    body.filePath = uploadData.filePath;
                }
                
                const res = await fetch(`${API_BASE}/process/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (!res.ok) throw new Error('Start failed');
                const data = await res.json();
                processorId = data.processorId;
                
                statusInterval = setInterval(fetchStatus, 100);  // Update every 100ms for smoother animation
                setTimeout(fetchStatus, 100);
            } catch (e) {
                alert('Error: ' + e.message);
                resetControls();
            }
        }
        
        async function stopProcessing() {
            if (processorId) {
                try { await fetch(`${API_BASE}/process/${processorId}/stop`, { method: 'POST' }); } catch(e) {}
            }
            // Don't fully cleanup - keep download buttons enabled if data exists
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            // Re-enable threshold controls when stopped
            document.getElementById('thresholdInput').disabled = false;
            document.getElementById('changeThresholdBtn').disabled = false;
            document.getElementById('statusBadge').className = 'status-badge status-idle';
            document.getElementById('statusBadge').textContent = '‚óè Stopped';
            // Download buttons remain enabled if data exists
        }
        
        async function fetchStatus() {
            if (!processorId) return;
            try {
                const res = await fetch(`${API_BASE}/process/${processorId}/status`);
                const data = await res.json();
                
                if (data.error) { alert(data.error); cleanup(); return; }
                
                updateMetrics(data.metrics);
                updateTrustScores(data.sensorData);
                updateTrajectory(data.trajectoryData, data.anomalies);
                updateAnomalies(data.anomalies);
                
                // Update download buttons based on available data
                updateDownloadButtons(data.metrics);
                
                // Update threshold display
                if (data.metrics && data.metrics.gpsAnomalyThreshold !== undefined) {
                    document.getElementById('currentThreshold').textContent = `Current: ${data.metrics.gpsAnomalyThreshold}¬∞`;
                    document.getElementById('thresholdInput').value = data.metrics.gpsAnomalyThreshold;
                }
                
                // Update live grid with latest GPS position
                if (data.trajectoryData && data.trajectoryData.length > 0) {
                    const latest = data.trajectoryData[data.trajectoryData.length - 1];
                    
                    // Update trust score dynamically when new predictions are received
                    if (data.predictions && data.predictions.length > 0) {
                        const latestPred = data.predictions[data.predictions.length - 1];
                        console.log('[PREDICTION] New prediction received:', latestPred);
                        console.log('  Current GPS:', latest.lat, latest.lon);
                        console.log('  Predicted GPS:', latestPred.predicted_lat, latestPred.predicted_lon);
                        
                        // Update trust score immediately when prediction is received
                        // Trust score should already be in sensorData, but ensure it's updated
                        if (data.sensorData && data.sensorData.gps) {
                            updateTrustScores(data.sensorData);
                            console.log('[TRUST] Trust score updated to:', (data.sensorData.gps.trustScore * 100).toFixed(2) + '%');
                        }
                    } else {
                        console.log('[PREDICTION] No predictions in data');
                    }
                    
                    updateLiveGrid(latest.lat, latest.lon, data.predictions);
                }
                
                // Also update trust score whenever sensorData changes (even without new predictions)
                if (data.sensorData && data.sensorData.gps) {
                    updateTrustScores(data.sensorData);
                }
                
                // Check if anomaly was detected and show popup
                if (data.hasAnomalyData && data.anomaly_motion_data) {
                    // Check if this anomaly was already dismissed
                    const anomalyTimestamp = data.anomaly_motion_data.anomaly_timestamp;
                    const isDismissed = window.dismissedAnomalies && window.dismissedAnomalies.has(anomalyTimestamp);
                    
                    console.log('[POPUP CHECK]', {
                        hasAnomalyData: data.hasAnomalyData,
                        hasMotionData: !!data.anomaly_motion_data,
                        popupShown: window.anomalyPopupShown,
                        anomalyTimestamp: anomalyTimestamp,
                        isDismissed: isDismissed,
                        dismissedSet: window.dismissedAnomalies ? Array.from(window.dismissedAnomalies) : null
                    });
                    
                    // Show popup if not already shown and not dismissed
                    if (!window.anomalyPopupShown && !isDismissed) {
                        console.log('[POPUP] Showing anomaly popup');
                        showAnomalyPopup(data.anomaly_motion_data, processorId);
                        window.anomalyPopupShown = true;
                    } else if (window.anomalyPopupShown) {
                        console.log('[POPUP] Popup already shown, skipping');
                    } else if (isDismissed) {
                        console.log('[POPUP] Anomaly was already dismissed, not showing');
                    }
                } else {
                    // Debug: log why popup is not showing
                    if (data.hasAnomalyData && !data.anomaly_motion_data) {
                        console.log('[POPUP] hasAnomalyData is true but anomaly_motion_data is missing');
                    } else if (!data.hasAnomalyData) {
                        console.log('[POPUP] hasAnomalyData is false');
                    }
                }
                
                // Reset popup flag if processing resumed or anomaly data cleared
                if (data.isProcessing && (!data.hasAnomalyData || !data.anomaly_motion_data)) {
                    window.anomalyPopupShown = false;
                }
                
                // When processing finishes, update UI but keep download buttons enabled
                if (!data.isProcessing && !data.isStopped) {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    // Re-enable threshold controls when processing completes
                    document.getElementById('thresholdInput').disabled = false;
                    document.getElementById('changeThresholdBtn').disabled = false;
                    document.getElementById('statusBadge').className = 'status-badge status-idle';
                    document.getElementById('statusBadge').textContent = '‚óè Complete';
                    // Download buttons remain enabled (handled by updateDownloadButtons)
                    if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }
                }
            } catch (e) { console.error(e); }
        }
        
        function updateMetrics(m) {
            document.getElementById('totalReadings').textContent = m.totalReadings;
            document.getElementById('anomaliesCount').textContent = m.anomaliesDetected;
            document.getElementById('detectionRate').textContent = m.detectionRate.toFixed(1) + '%';
            document.getElementById('avgTime').textContent = m.avgProcessingTime.toFixed(2) + 'ms';
            document.getElementById('currentTime').textContent = m.currentTimestamp.toFixed(1) + 's';
        }
        
        function updateTrustScores(s) {
            if (!s) {
                console.log('[TRUST] No sensor data provided');
                return;
            }
            
            // Get GPS trust score (based on prediction accuracy)
            const score = (s.gps?.trustScore || 1) * 100;
            const el = document.getElementById('trustScore');
            const bar = document.getElementById('trustBar');
            
            if (el) {
                el.textContent = score.toFixed(1) + '%';
                console.log('[TRUST] Updated trust score display to:', score.toFixed(1) + '%');
            }
            
            if (bar) {
                bar.style.width = score + '%';
                bar.className = 'trust-fill ' + (score > 80 ? 'trust-high' : score > 50 ? 'trust-medium' : 'trust-low');
                console.log('[TRUST] Updated trust bar width to:', score + '%');
            }
            
            // Log trust score details for debugging
            if (s.gps) {
                console.log('[TRUST] Trust score details:', {
                    trustScore: s.gps.trustScore,
                    percentage: score,
                    errorPercentage: s.gps.errorPercentage
                });
            }
        }
        
        function updateTrajectory(traj, anomalies) {
            if (!traj || !traj.length) { drawEmptyCanvas(); return; }
            
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * canvas.width / 10, 0);
                ctx.lineTo(i * canvas.width / 10, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * canvas.height / 10);
                ctx.lineTo(canvas.width, i * canvas.height / 10);
                ctx.stroke();
            }
            
            const lats = traj.map(d => d.lat), lons = traj.map(d => d.lon);
            const minLat = Math.min(...lats), maxLat = Math.max(...lats);
            const minLon = Math.min(...lons), maxLon = Math.max(...lons);
            const pad = 40;
            const scaleX = (canvas.width - 2*pad) / (maxLon - minLon || 1);
            const scaleY = (canvas.height - 2*pad) / (maxLat - minLat || 1);
            const toX = lon => pad + (lon - minLon) * scaleX;
            const toY = lat => canvas.height - (pad + (lat - minLat) * scaleY);
            
            // Path
            ctx.lineWidth = 3;
            for (let i = 1; i < traj.length; i++) {
                ctx.strokeStyle = traj[i].isPoisoned ? '#ff4757' : '#00d4ff';
                ctx.beginPath();
                ctx.moveTo(toX(traj[i-1].lon), toY(traj[i-1].lat));
                ctx.lineTo(toX(traj[i].lon), toY(traj[i].lat));
                ctx.stroke();
            }
            
            // Anomaly flags
            if (anomalies) {
                anomalies.forEach(a => {
                    const x = toX(a.position.lon), y = toY(a.position.lat);
                    ctx.strokeStyle = '#ff4757';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y - 15);
                    ctx.stroke();
                    ctx.fillStyle = '#ff4757';
                    ctx.beginPath();
                    ctx.moveTo(x, y - 15);
                    ctx.lineTo(x + 10, y - 10);
                    ctx.lineTo(x, y - 5);
                    ctx.fill();
                });
            }
            
            // Start point
            ctx.fillStyle = '#2ed573';
            ctx.beginPath();
            ctx.arc(toX(traj[0].lon), toY(traj[0].lat), 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Current point
            const curr = traj[traj.length - 1];
            ctx.fillStyle = '#a55eea';
            ctx.beginPath();
            ctx.arc(toX(curr.lon), toY(curr.lat), 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function updateAnomalies(anomalies) {
            const el = document.getElementById('anomalyList');
            if (!anomalies || !anomalies.length) {
                el.innerHTML = '<div style="text-align:center;color:#666;padding:20px;">No anomalies detected</div>';
                return;
            }
            el.innerHTML = anomalies.slice(-5).reverse().map(a => `
                <div class="anomaly-item">
                    <div class="anomaly-time">t=${a.timestamp.toFixed(2)}s | Severity: ${(a.severity*100).toFixed(0)}%</div>
                    <div class="anomaly-reasons">${a.reasons.join(' ‚Ä¢ ')}</div>
                </div>
            `).join('');
        }
        
        function resetControls(keepDownloadsEnabled = false) {
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            // Re-enable threshold controls when not processing
            document.getElementById('thresholdInput').disabled = false;
            document.getElementById('changeThresholdBtn').disabled = false;
            // Keep download buttons enabled if data exists, or if explicitly requested
            if (!keepDownloadsEnabled) {
                document.getElementById('downloadAllBtn').disabled = true;
                document.getElementById('downloadAnomaliesBtn').disabled = true;
            }
            document.getElementById('statusBadge').className = 'status-badge status-idle';
            document.getElementById('statusBadge').textContent = '‚óè Idle';
            // Reset live grid
            currentPosition = null;
            positionHistory = [];
            gridBounds = { minLat: null, maxLat: null, minLon: null, maxLon: null };
            drawEmptyGrid();
        }
        
        function updateDownloadButtons(data) {
            // Enable download buttons if there's data available
            const hasReadings = data.totalReadings > 0;
            const hasAnomalies = data.anomaliesDetected > 0;
            
            document.getElementById('downloadAllBtn').disabled = !hasReadings;
            document.getElementById('downloadAnomaliesBtn').disabled = !hasAnomalies;
        }
        
        function cleanup() {
            if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }
            // Only fully reset if there's no data to preserve
            resetControls(false);
        }
        
        async function downloadAllData() {
            if (!processorId) {
                alert('No processor found. Please start processing first.');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/process/${processorId}/download/all`);
                if (!response.ok) {
                    const error = await response.json();
                    alert('Error downloading data: ' + (error.error || 'No data available. Please process a bag file first.'));
                    return;
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `all_sensor_data_${processorId}.csv`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (e) {
                alert('Error downloading data: ' + e.message);
            }
        }
        
        async function downloadAnomalies() {
            if (!processorId) {
                alert('No processor found. Please start processing first.');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/process/${processorId}/download/anomalies`);
                if (!response.ok) {
                    const error = await response.json();
                    alert('Error downloading anomalies: ' + (error.error || 'No anomalies found. No anomalies were detected during processing.'));
                    return;
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `anomalies_${processorId}.csv`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (e) {
                alert('Error downloading anomalies: ' + e.message);
            }
        }
        
        // Store threshold globally for use when starting processing
        let globalThreshold = 2.0;
        
        async function changeThreshold() {
            const thresholdInput = document.getElementById('thresholdInput');
            const threshold = parseFloat(thresholdInput.value);
            
            if (isNaN(threshold) || threshold <= 0) {
                alert('Please enter a valid positive number for the threshold.');
                return;
            }
            
            // Store globally for future processing
            globalThreshold = threshold;
            
            // If processor exists and is not running, update it
            if (processorId) {
                // Check if processing is running (button should be disabled, but double-check)
                const stopBtn = document.getElementById('stopBtn');
                if (!stopBtn.disabled) {
                    alert('Cannot change threshold while processing is running. Please stop processing first.');
                    return;
                }
                
                try {
                    const response = await fetch(`${API_BASE}/process/${processorId}/set-threshold`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ threshold: threshold })
                    });
                    
                    const result = await response.json();
                    if (response.ok) {
                        alert(`Threshold updated to ${threshold}¬∞`);
                        document.getElementById('currentThreshold').textContent = `Current: ${threshold}¬∞`;
                        return;
                    } else {
                        alert('Error updating threshold: ' + (result.error || 'Unknown error'));
                        return;
                    }
                } catch (e) {
                    alert('Error updating threshold: ' + e.message);
                    return;
                }
            }
            
            // If no processor, just update the display (will be used when processing starts)
            alert(`Threshold set to ${threshold}¬∞. This will be used when you start processing.`);
            document.getElementById('currentThreshold').textContent = `Current: ${threshold}¬∞`;
        }
        
        async function loadPresets() {
            try {
                const res = await fetch(`${API_BASE}/poison/presets`);
                const data = await res.json();
                document.getElementById('presetGrid').innerHTML = data.presets.map(p => `
                    <div class="preset-card" onclick="selectPreset('${p}', this)">
                        <div class="preset-name">${p}</div>
                        <div class="preset-desc">${data.descriptions[p]}</div>
                    </div>
                `).join('');
            } catch (e) { console.error(e); }
        }
        
        function selectPreset(preset, el) {
            document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            selectedPreset = preset;
        }
        
        async function applyPreset() {
            if (!selectedPreset) { alert('Select a preset first'); return; }
            try {
                const res = await fetch(`${API_BASE}/poison/inject`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preset: selectedPreset, clear_existing: true })
                });
                const data = await res.json();
                alert(data.message || 'Preset applied');
                getPoisonStatus();
            } catch (e) { alert('Error: ' + e.message); }
        }
        
        async function addCustomPoison() {
            const config = {
                poison_type: document.getElementById('poisonType').value,
                start_time: parseFloat(document.getElementById('startTime').value),
                duration: parseFloat(document.getElementById('duration').value),
                intensity: parseFloat(document.getElementById('intensity').value),
                jump_distance: parseFloat(document.getElementById('jumpDistance').value)
            };
            try {
                const res = await fetch(`${API_BASE}/poison/inject`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                const data = await res.json();
                alert(data.message || 'Poison added');
                getPoisonStatus();
            } catch (e) { alert('Error: ' + e.message); }
        }
        
        async function clearPoisons() {
            try {
                await fetch(`${API_BASE}/poison/clear`, { method: 'POST' });
                alert('All poisons cleared');
                getPoisonStatus();
            } catch (e) { alert('Error: ' + e.message); }
        }
        
        async function getPoisonStatus() {
            try {
                const res = await fetch(`${API_BASE}/poison/status`);
                const data = await res.json();
                document.getElementById('poisonStatus').innerHTML = `
                    <div class="card">
                        <h2>üìä Poison Status: ${data.status.toUpperCase()}</h2>
                        <div class="metrics-row">
                            <div class="metric-box"><div class="metric-label">Active</div><div class="metric-value">${data.statistics.active_poisons}</div></div>
                            <div class="metric-box"><div class="metric-label">Injections</div><div class="metric-value">${data.statistics.total_injections}</div></div>
                            <div class="metric-box"><div class="metric-label">Types</div><div class="metric-value">${data.statistics.poison_types.length}</div></div>
                        </div>
                        ${data.statistics.poison_types.length ? '<p style="margin-top:10px"><strong>Types:</strong> ' + data.statistics.poison_types.join(', ') + '</p>' : ''}
                    </div>
                `;
            } catch (e) { console.error(e); }
        }
        
        async function validateDetection() {
            const id = prompt('Processor ID:', 'processor_0');
            if (!id) return;
            try {
                const res = await fetch(`${API_BASE}/poison/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ processor_id: id })
                });
                const data = await res.json();
                const v = data.validation;
                document.getElementById('validationResults').innerHTML = `
                    <div class="card">
                        <h2>‚úì Results: ${v.detection_rate.toFixed(1)}% Detection Rate</h2>
                        <div class="status-box ${v.detection_rate > 80 ? 'success' : v.detection_rate > 50 ? 'warning' : 'error'}">
                            ${v.detection_rate > 80 ? '‚úÖ Excellent' : v.detection_rate > 50 ? '‚ö†Ô∏è Moderate' : '‚ùå Poor'}
                        </div>
                        <div class="validation-metrics">
                            <div class="metric-box"><div class="metric-label">True +</div><div class="metric-value success">${v.true_positives}</div></div>
                            <div class="metric-box"><div class="metric-label">False -</div><div class="metric-value danger">${v.false_negatives}</div></div>
                            <div class="metric-box"><div class="metric-label">False +</div><div class="metric-value danger">${v.false_positives}</div></div>
                            <div class="metric-box"><div class="metric-label">Precision</div><div class="metric-value">${(v.precision*100).toFixed(0)}%</div></div>
                            <div class="metric-box"><div class="metric-label">Recall</div><div class="metric-value">${(v.recall*100).toFixed(0)}%</div></div>
                            <div class="metric-box"><div class="metric-label">F1</div><div class="metric-value">${(v.f1_score*100).toFixed(0)}%</div></div>
                        </div>
                    </div>
                `;
            } catch (e) { alert('Error: ' + e.message); }
        }
        
        async function loadPoisonTypes() {
            try {
                const res = await fetch(`${API_BASE}/poison/types`);
                const data = await res.json();
                document.getElementById('poisonTypesList').innerHTML = Object.entries(data.poison_types).map(([t, d]) =>
                    `<div style="padding:10px;background:rgba(255,255,255,0.05);border-radius:5px;"><strong style="color:#00d4ff">${t}</strong><br><span style="font-size:12px;color:#888">${d}</span></div>`
                ).join('');
            } catch (e) { console.error(e); }
        }
    </script>
</body>
</html>
